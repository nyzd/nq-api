/* tslint:disable */
/* eslint-disable */
/**
 * Natiq API
 * Natiq Quran API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from '../configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, type RequestArgs, BaseAPI, RequiredError, operationServerMap } from '../base';
// @ts-ignore
import type { AyahTranslation } from '../models';
// @ts-ignore
import type { PatchedTranslationList } from '../models';
// @ts-ignore
import type { Translation } from '../models';
// @ts-ignore
import type { TranslationList } from '../models';
// @ts-ignore
import type { TranslationsAyahsUpdateRequest } from '../models';
/**
 * TranslationsApi - axios parameter creator
 */
export const TranslationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Provide the ayah\'s UUID in the URL path and the translation\'s UUID as the primary resource path. Body requires only `text` (and optional `bismillah`). If an AyahTranslation already exists it will be updated, otherwise it will be created.
         * @summary Create or update (upsert) a specific AyahTranslation
         * @param {string} ayahUuid 
         * @param {string} uuid 
         * @param {TranslationsAyahsUpdateRequest} [translationsAyahsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsAyahsCreate: async (ayahUuid: string, uuid: string, translationsAyahsUpdateRequest?: TranslationsAyahsUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ayahUuid' is not null or undefined
            assertParamExists('translationsAyahsCreate', 'ayahUuid', ayahUuid)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('translationsAyahsCreate', 'uuid', uuid)
            const localVarPath = `/translations/{uuid}/ayahs/{ayah_uuid}/`
                .replace(`{${"ayah_uuid"}}`, encodeURIComponent(String(ayahUuid)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(translationsAyahsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a paginated list of all AyahTranslation objects for the given Translation UUID. Optionally filter by surah_uuid (query param).
         * @summary List all AyahTranslations for this Translation
         * @param {string} uuid 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {TranslationsAyahsListOrderingEnum} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {string} [surahUuid] UUID of the Surah to filter AyahTranslations by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsAyahsList: async (uuid: string, limit?: number, offset?: number, ordering?: TranslationsAyahsListOrderingEnum, search?: string, surahUuid?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('translationsAyahsList', 'uuid', uuid)
            const localVarPath = `/translations/{uuid}/ayahs/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (surahUuid !== undefined) {
                localVarQueryParameter['surah_uuid'] = surahUuid;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single AyahTranslation object for the given Translation UUID and Ayah UUID. URL: /translations/{translation_uuid}/ayahs/{ayah_uuid}/
         * @summary Retrieve a single AyahTranslation for this Translation
         * @param {string} ayahUuid 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsAyahsRetrieve: async (ayahUuid: string, uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ayahUuid' is not null or undefined
            assertParamExists('translationsAyahsRetrieve', 'ayahUuid', ayahUuid)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('translationsAyahsRetrieve', 'uuid', uuid)
            const localVarPath = `/translations/{uuid}/ayahs/{ayah_uuid}/`
                .replace(`{${"ayah_uuid"}}`, encodeURIComponent(String(ayahUuid)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Provide the ayah\'s UUID in the URL path and the translation\'s UUID as the primary resource path. Body requires only `text` (and optional `bismillah`). If an AyahTranslation already exists it will be updated, otherwise it will be created.
         * @summary Create or update (upsert) a specific AyahTranslation
         * @param {string} ayahUuid 
         * @param {string} uuid 
         * @param {TranslationsAyahsUpdateRequest} [translationsAyahsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsAyahsUpdate: async (ayahUuid: string, uuid: string, translationsAyahsUpdateRequest?: TranslationsAyahsUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ayahUuid' is not null or undefined
            assertParamExists('translationsAyahsUpdate', 'ayahUuid', ayahUuid)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('translationsAyahsUpdate', 'uuid', uuid)
            const localVarPath = `/translations/{uuid}/ayahs/{ayah_uuid}/`
                .replace(`{${"ayah_uuid"}}`, encodeURIComponent(String(ayahUuid)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(translationsAyahsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a new Translation record
         * @param {TranslationList} translationList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsCreate: async (translationList: TranslationList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'translationList' is not null or undefined
            assertParamExists('translationsCreate', 'translationList', translationList)
            const localVarPath = `/translations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(translationList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a Translation record
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsDestroy: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('translationsDestroy', 'uuid', uuid)
            const localVarPath = `/translations/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Import a Translation from a JSON file upload
         * @param {File} file JSON file containing the Translation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsImportCreate: async (file: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('translationsImportCreate', 'file', file)
            const localVarPath = `/translations/import/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List all Quran Translations
         * @param {TranslationsListMushafEnum} mushaf Short name of the Mushaf to filter Translations by. Common value: \&#39;hafs\&#39;. Any string is accepted. (e.g. \&#39;hafs\&#39;, \&#39;warsh\&#39;, etc.)
         * @param {TranslationsListLanguageEnum} [language] Language code to filter Translations by.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {TranslationsListOrderingEnum} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsList: async (mushaf: TranslationsListMushafEnum, language?: TranslationsListLanguageEnum, limit?: number, offset?: number, ordering?: TranslationsListOrderingEnum, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mushaf' is not null or undefined
            assertParamExists('translationsList', 'mushaf', mushaf)
            const localVarPath = `/translations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (mushaf !== undefined) {
                localVarQueryParameter['mushaf'] = mushaf;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (ordering !== undefined) {
                localVarQueryParameter['ordering'] = ordering;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partially update a Translation record
         * @param {string} uuid 
         * @param {PatchedTranslationList} [patchedTranslationList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsPartialUpdate: async (uuid: string, patchedTranslationList?: PatchedTranslationList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('translationsPartialUpdate', 'uuid', uuid)
            const localVarPath = `/translations/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchedTranslationList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a specific Translation by UUID
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsRetrieve: async (uuid: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('translationsRetrieve', 'uuid', uuid)
            const localVarPath = `/translations/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Translation record
         * @param {string} uuid 
         * @param {TranslationList} translationList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsUpdate: async (uuid: string, translationList: TranslationList, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('translationsUpdate', 'uuid', uuid)
            // verify required parameter 'translationList' is not null or undefined
            assertParamExists('translationsUpdate', 'translationList', translationList)
            const localVarPath = `/translations/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication knoxApiToken required
            await setApiKeyToObject(localVarHeaderParameter, "Authorization", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(translationList, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TranslationsApi - functional programming interface
 */
export const TranslationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TranslationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Provide the ayah\'s UUID in the URL path and the translation\'s UUID as the primary resource path. Body requires only `text` (and optional `bismillah`). If an AyahTranslation already exists it will be updated, otherwise it will be created.
         * @summary Create or update (upsert) a specific AyahTranslation
         * @param {string} ayahUuid 
         * @param {string} uuid 
         * @param {TranslationsAyahsUpdateRequest} [translationsAyahsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsAyahsCreate(ayahUuid: string, uuid: string, translationsAyahsUpdateRequest?: TranslationsAyahsUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AyahTranslation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsAyahsCreate(ayahUuid, uuid, translationsAyahsUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslationsApi.translationsAyahsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a paginated list of all AyahTranslation objects for the given Translation UUID. Optionally filter by surah_uuid (query param).
         * @summary List all AyahTranslations for this Translation
         * @param {string} uuid 
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {TranslationsAyahsListOrderingEnum} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {string} [surahUuid] UUID of the Surah to filter AyahTranslations by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsAyahsList(uuid: string, limit?: number, offset?: number, ordering?: TranslationsAyahsListOrderingEnum, search?: string, surahUuid?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AyahTranslation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsAyahsList(uuid, limit, offset, ordering, search, surahUuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslationsApi.translationsAyahsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns a single AyahTranslation object for the given Translation UUID and Ayah UUID. URL: /translations/{translation_uuid}/ayahs/{ayah_uuid}/
         * @summary Retrieve a single AyahTranslation for this Translation
         * @param {string} ayahUuid 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsAyahsRetrieve(ayahUuid: string, uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AyahTranslation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsAyahsRetrieve(ayahUuid, uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslationsApi.translationsAyahsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Provide the ayah\'s UUID in the URL path and the translation\'s UUID as the primary resource path. Body requires only `text` (and optional `bismillah`). If an AyahTranslation already exists it will be updated, otherwise it will be created.
         * @summary Create or update (upsert) a specific AyahTranslation
         * @param {string} ayahUuid 
         * @param {string} uuid 
         * @param {TranslationsAyahsUpdateRequest} [translationsAyahsUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsAyahsUpdate(ayahUuid: string, uuid: string, translationsAyahsUpdateRequest?: TranslationsAyahsUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AyahTranslation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsAyahsUpdate(ayahUuid, uuid, translationsAyahsUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslationsApi.translationsAyahsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Create a new Translation record
         * @param {TranslationList} translationList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsCreate(translationList: TranslationList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsCreate(translationList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslationsApi.translationsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a Translation record
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsDestroy(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsDestroy(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslationsApi.translationsDestroy']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Import a Translation from a JSON file upload
         * @param {File} file JSON file containing the Translation data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsImportCreate(file: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsImportCreate(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslationsApi.translationsImportCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List all Quran Translations
         * @param {TranslationsListMushafEnum} mushaf Short name of the Mushaf to filter Translations by. Common value: \&#39;hafs\&#39;. Any string is accepted. (e.g. \&#39;hafs\&#39;, \&#39;warsh\&#39;, etc.)
         * @param {TranslationsListLanguageEnum} [language] Language code to filter Translations by.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {TranslationsListOrderingEnum} [ordering] Which field to use when ordering the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsList(mushaf: TranslationsListMushafEnum, language?: TranslationsListLanguageEnum, limit?: number, offset?: number, ordering?: TranslationsListOrderingEnum, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TranslationList>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsList(mushaf, language, limit, offset, ordering, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslationsApi.translationsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partially update a Translation record
         * @param {string} uuid 
         * @param {PatchedTranslationList} [patchedTranslationList] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsPartialUpdate(uuid: string, patchedTranslationList?: PatchedTranslationList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsPartialUpdate(uuid, patchedTranslationList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslationsApi.translationsPartialUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Retrieve a specific Translation by UUID
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsRetrieve(uuid: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Translation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsRetrieve(uuid, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslationsApi.translationsRetrieve']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing Translation record
         * @param {string} uuid 
         * @param {TranslationList} translationList 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async translationsUpdate(uuid: string, translationList: TranslationList, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TranslationList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.translationsUpdate(uuid, translationList, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TranslationsApi.translationsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TranslationsApi - factory interface
 */
export const TranslationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TranslationsApiFp(configuration)
    return {
        /**
         * Provide the ayah\'s UUID in the URL path and the translation\'s UUID as the primary resource path. Body requires only `text` (and optional `bismillah`). If an AyahTranslation already exists it will be updated, otherwise it will be created.
         * @summary Create or update (upsert) a specific AyahTranslation
         * @param {TranslationsApiTranslationsAyahsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsAyahsCreate(requestParameters: TranslationsApiTranslationsAyahsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AyahTranslation> {
            return localVarFp.translationsAyahsCreate(requestParameters.ayahUuid, requestParameters.uuid, requestParameters.translationsAyahsUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a paginated list of all AyahTranslation objects for the given Translation UUID. Optionally filter by surah_uuid (query param).
         * @summary List all AyahTranslations for this Translation
         * @param {TranslationsApiTranslationsAyahsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsAyahsList(requestParameters: TranslationsApiTranslationsAyahsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<AyahTranslation>> {
            return localVarFp.translationsAyahsList(requestParameters.uuid, requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.search, requestParameters.surahUuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single AyahTranslation object for the given Translation UUID and Ayah UUID. URL: /translations/{translation_uuid}/ayahs/{ayah_uuid}/
         * @summary Retrieve a single AyahTranslation for this Translation
         * @param {TranslationsApiTranslationsAyahsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsAyahsRetrieve(requestParameters: TranslationsApiTranslationsAyahsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<AyahTranslation> {
            return localVarFp.translationsAyahsRetrieve(requestParameters.ayahUuid, requestParameters.uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * Provide the ayah\'s UUID in the URL path and the translation\'s UUID as the primary resource path. Body requires only `text` (and optional `bismillah`). If an AyahTranslation already exists it will be updated, otherwise it will be created.
         * @summary Create or update (upsert) a specific AyahTranslation
         * @param {TranslationsApiTranslationsAyahsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsAyahsUpdate(requestParameters: TranslationsApiTranslationsAyahsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AyahTranslation> {
            return localVarFp.translationsAyahsUpdate(requestParameters.ayahUuid, requestParameters.uuid, requestParameters.translationsAyahsUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a new Translation record
         * @param {TranslationsApiTranslationsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsCreate(requestParameters: TranslationsApiTranslationsCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TranslationList> {
            return localVarFp.translationsCreate(requestParameters.translationList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a Translation record
         * @param {TranslationsApiTranslationsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsDestroy(requestParameters: TranslationsApiTranslationsDestroyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.translationsDestroy(requestParameters.uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Import a Translation from a JSON file upload
         * @param {TranslationsApiTranslationsImportCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsImportCreate(requestParameters: TranslationsApiTranslationsImportCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TranslationList> {
            return localVarFp.translationsImportCreate(requestParameters.file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List all Quran Translations
         * @param {TranslationsApiTranslationsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsList(requestParameters: TranslationsApiTranslationsListRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<TranslationList>> {
            return localVarFp.translationsList(requestParameters.mushaf, requestParameters.language, requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partially update a Translation record
         * @param {TranslationsApiTranslationsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsPartialUpdate(requestParameters: TranslationsApiTranslationsPartialUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TranslationList> {
            return localVarFp.translationsPartialUpdate(requestParameters.uuid, requestParameters.patchedTranslationList, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a specific Translation by UUID
         * @param {TranslationsApiTranslationsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsRetrieve(requestParameters: TranslationsApiTranslationsRetrieveRequest, options?: RawAxiosRequestConfig): AxiosPromise<Translation> {
            return localVarFp.translationsRetrieve(requestParameters.uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Translation record
         * @param {TranslationsApiTranslationsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        translationsUpdate(requestParameters: TranslationsApiTranslationsUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<TranslationList> {
            return localVarFp.translationsUpdate(requestParameters.uuid, requestParameters.translationList, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for translationsAyahsCreate operation in TranslationsApi.
 */
export interface TranslationsApiTranslationsAyahsCreateRequest {
    readonly ayahUuid: string

    readonly uuid: string

    readonly translationsAyahsUpdateRequest?: TranslationsAyahsUpdateRequest
}

/**
 * Request parameters for translationsAyahsList operation in TranslationsApi.
 */
export interface TranslationsApiTranslationsAyahsListRequest {
    readonly uuid: string

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Which field to use when ordering the results.
     */
    readonly ordering?: TranslationsAyahsListOrderingEnum

    /**
     * A search term.
     */
    readonly search?: string

    /**
     * UUID of the Surah to filter AyahTranslations by.
     */
    readonly surahUuid?: string
}

/**
 * Request parameters for translationsAyahsRetrieve operation in TranslationsApi.
 */
export interface TranslationsApiTranslationsAyahsRetrieveRequest {
    readonly ayahUuid: string

    readonly uuid: string
}

/**
 * Request parameters for translationsAyahsUpdate operation in TranslationsApi.
 */
export interface TranslationsApiTranslationsAyahsUpdateRequest {
    readonly ayahUuid: string

    readonly uuid: string

    readonly translationsAyahsUpdateRequest?: TranslationsAyahsUpdateRequest
}

/**
 * Request parameters for translationsCreate operation in TranslationsApi.
 */
export interface TranslationsApiTranslationsCreateRequest {
    readonly translationList: TranslationList
}

/**
 * Request parameters for translationsDestroy operation in TranslationsApi.
 */
export interface TranslationsApiTranslationsDestroyRequest {
    readonly uuid: string
}

/**
 * Request parameters for translationsImportCreate operation in TranslationsApi.
 */
export interface TranslationsApiTranslationsImportCreateRequest {
    /**
     * JSON file containing the Translation data
     */
    readonly file: File
}

/**
 * Request parameters for translationsList operation in TranslationsApi.
 */
export interface TranslationsApiTranslationsListRequest {
    /**
     * Short name of the Mushaf to filter Translations by. Common value: \&#39;hafs\&#39;. Any string is accepted. (e.g. \&#39;hafs\&#39;, \&#39;warsh\&#39;, etc.)
     */
    readonly mushaf: TranslationsListMushafEnum

    /**
     * Language code to filter Translations by.
     */
    readonly language?: TranslationsListLanguageEnum

    /**
     * Number of results to return per page.
     */
    readonly limit?: number

    /**
     * The initial index from which to return the results.
     */
    readonly offset?: number

    /**
     * Which field to use when ordering the results.
     */
    readonly ordering?: TranslationsListOrderingEnum

    /**
     * A search term.
     */
    readonly search?: string
}

/**
 * Request parameters for translationsPartialUpdate operation in TranslationsApi.
 */
export interface TranslationsApiTranslationsPartialUpdateRequest {
    readonly uuid: string

    readonly patchedTranslationList?: PatchedTranslationList
}

/**
 * Request parameters for translationsRetrieve operation in TranslationsApi.
 */
export interface TranslationsApiTranslationsRetrieveRequest {
    readonly uuid: string
}

/**
 * Request parameters for translationsUpdate operation in TranslationsApi.
 */
export interface TranslationsApiTranslationsUpdateRequest {
    readonly uuid: string

    readonly translationList: TranslationList
}

/**
 * TranslationsApi - object-oriented interface
 */
export class TranslationsApi extends BaseAPI {
    /**
     * Provide the ayah\'s UUID in the URL path and the translation\'s UUID as the primary resource path. Body requires only `text` (and optional `bismillah`). If an AyahTranslation already exists it will be updated, otherwise it will be created.
     * @summary Create or update (upsert) a specific AyahTranslation
     * @param {TranslationsApiTranslationsAyahsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translationsAyahsCreate(requestParameters: TranslationsApiTranslationsAyahsCreateRequest, options?: RawAxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsAyahsCreate(requestParameters.ayahUuid, requestParameters.uuid, requestParameters.translationsAyahsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a paginated list of all AyahTranslation objects for the given Translation UUID. Optionally filter by surah_uuid (query param).
     * @summary List all AyahTranslations for this Translation
     * @param {TranslationsApiTranslationsAyahsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translationsAyahsList(requestParameters: TranslationsApiTranslationsAyahsListRequest, options?: RawAxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsAyahsList(requestParameters.uuid, requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.search, requestParameters.surahUuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single AyahTranslation object for the given Translation UUID and Ayah UUID. URL: /translations/{translation_uuid}/ayahs/{ayah_uuid}/
     * @summary Retrieve a single AyahTranslation for this Translation
     * @param {TranslationsApiTranslationsAyahsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translationsAyahsRetrieve(requestParameters: TranslationsApiTranslationsAyahsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsAyahsRetrieve(requestParameters.ayahUuid, requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Provide the ayah\'s UUID in the URL path and the translation\'s UUID as the primary resource path. Body requires only `text` (and optional `bismillah`). If an AyahTranslation already exists it will be updated, otherwise it will be created.
     * @summary Create or update (upsert) a specific AyahTranslation
     * @param {TranslationsApiTranslationsAyahsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translationsAyahsUpdate(requestParameters: TranslationsApiTranslationsAyahsUpdateRequest, options?: RawAxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsAyahsUpdate(requestParameters.ayahUuid, requestParameters.uuid, requestParameters.translationsAyahsUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a new Translation record
     * @param {TranslationsApiTranslationsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translationsCreate(requestParameters: TranslationsApiTranslationsCreateRequest, options?: RawAxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsCreate(requestParameters.translationList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a Translation record
     * @param {TranslationsApiTranslationsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translationsDestroy(requestParameters: TranslationsApiTranslationsDestroyRequest, options?: RawAxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsDestroy(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Import a Translation from a JSON file upload
     * @param {TranslationsApiTranslationsImportCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translationsImportCreate(requestParameters: TranslationsApiTranslationsImportCreateRequest, options?: RawAxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsImportCreate(requestParameters.file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List all Quran Translations
     * @param {TranslationsApiTranslationsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translationsList(requestParameters: TranslationsApiTranslationsListRequest, options?: RawAxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsList(requestParameters.mushaf, requestParameters.language, requestParameters.limit, requestParameters.offset, requestParameters.ordering, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partially update a Translation record
     * @param {TranslationsApiTranslationsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translationsPartialUpdate(requestParameters: TranslationsApiTranslationsPartialUpdateRequest, options?: RawAxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsPartialUpdate(requestParameters.uuid, requestParameters.patchedTranslationList, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a specific Translation by UUID
     * @param {TranslationsApiTranslationsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translationsRetrieve(requestParameters: TranslationsApiTranslationsRetrieveRequest, options?: RawAxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsRetrieve(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Translation record
     * @param {TranslationsApiTranslationsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public translationsUpdate(requestParameters: TranslationsApiTranslationsUpdateRequest, options?: RawAxiosRequestConfig) {
        return TranslationsApiFp(this.configuration).translationsUpdate(requestParameters.uuid, requestParameters.translationList, options).then((request) => request(this.axios, this.basePath));
    }
}

export const TranslationsAyahsListOrderingEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type TranslationsAyahsListOrderingEnum = typeof TranslationsAyahsListOrderingEnum[keyof typeof TranslationsAyahsListOrderingEnum];
export const TranslationsListMushafEnum = {
    Hafs: 'hafs'
} as const;
export type TranslationsListMushafEnum = typeof TranslationsListMushafEnum[keyof typeof TranslationsListMushafEnum];
export const TranslationsListLanguageEnum = {
    Ber: 'ber',
    Aa: 'aa',
    Ab: 'ab',
    Ae: 'ae',
    Af: 'af',
    Ak: 'ak',
    Am: 'am',
    An: 'an',
    Ar: 'ar',
    As: 'as',
    Av: 'av',
    Ay: 'ay',
    Az: 'az',
    Ba: 'ba',
    Be: 'be',
    Bg: 'bg',
    Bh: 'bh',
    Bi: 'bi',
    Bm: 'bm',
    Bn: 'bn',
    Bo: 'bo',
    Br: 'br',
    Bs: 'bs',
    Ca: 'ca',
    Ce: 'ce',
    Ch: 'ch',
    Co: 'co',
    Cr: 'cr',
    Cs: 'cs',
    Cu: 'cu',
    Cv: 'cv',
    Cy: 'cy',
    Da: 'da',
    De: 'de',
    Dv: 'dv',
    Dz: 'dz',
    Ee: 'ee',
    El: 'el',
    En: 'en',
    Eo: 'eo',
    Es: 'es',
    Et: 'et',
    Eu: 'eu',
    Fa: 'fa',
    Ff: 'ff',
    Fi: 'fi',
    Fj: 'fj',
    Fo: 'fo',
    Fr: 'fr',
    Fy: 'fy',
    Ga: 'ga',
    Gd: 'gd',
    Gl: 'gl',
    Gn: 'gn',
    Gu: 'gu',
    Gv: 'gv',
    Ha: 'ha',
    He: 'he',
    Hi: 'hi',
    Ho: 'ho',
    Hr: 'hr',
    Ht: 'ht',
    Hu: 'hu',
    Hy: 'hy',
    Hz: 'hz',
    Ia: 'ia',
    Id: 'id',
    Ie: 'ie',
    Ig: 'ig',
    Ii: 'ii',
    Ik: 'ik',
    Io: 'io',
    Is: 'is',
    It: 'it',
    Iu: 'iu',
    Ja: 'ja',
    Jv: 'jv',
    Ka: 'ka',
    Kg: 'kg',
    Ki: 'ki',
    Kj: 'kj',
    Kk: 'kk',
    Kl: 'kl',
    Km: 'km',
    Kn: 'kn',
    Ko: 'ko',
    Kr: 'kr',
    Ks: 'ks',
    Ku: 'ku',
    Kv: 'kv',
    Kw: 'kw',
    Ky: 'ky',
    La: 'la',
    Lb: 'lb',
    Lg: 'lg',
    Li: 'li',
    Ln: 'ln',
    Lo: 'lo',
    Lt: 'lt',
    Lu: 'lu',
    Lv: 'lv',
    Mg: 'mg',
    Mh: 'mh',
    Mi: 'mi',
    Mk: 'mk',
    Ml: 'ml',
    Mn: 'mn',
    Mr: 'mr',
    Ms: 'ms',
    Mt: 'mt',
    My: 'my',
    Na: 'na',
    Nb: 'nb',
    Nd: 'nd',
    Ne: 'ne',
    Ng: 'ng',
    Nl: 'nl',
    Nn: 'nn',
    No: 'no',
    Nr: 'nr',
    Nv: 'nv',
    Ny: 'ny',
    Oc: 'oc',
    Oj: 'oj',
    Om: 'om',
    Or: 'or',
    Os: 'os',
    Pa: 'pa',
    Pi: 'pi',
    Pl: 'pl',
    Ps: 'ps',
    Pt: 'pt',
    Qu: 'qu',
    Rm: 'rm',
    Rn: 'rn',
    Ro: 'ro',
    Ru: 'ru',
    Rw: 'rw',
    Sa: 'sa',
    Sc: 'sc',
    Sd: 'sd',
    Se: 'se',
    Sg: 'sg',
    Si: 'si',
    Sk: 'sk',
    Sl: 'sl',
    Sm: 'sm',
    Sn: 'sn',
    So: 'so',
    Sq: 'sq',
    Sr: 'sr',
    Ss: 'ss',
    St: 'st',
    Su: 'su',
    Sv: 'sv',
    Sw: 'sw',
    Ta: 'ta',
    Te: 'te',
    Tg: 'tg',
    Th: 'th',
    Ti: 'ti',
    Tk: 'tk',
    Tl: 'tl',
    Tn: 'tn',
    To: 'to',
    Tr: 'tr',
    Ts: 'ts',
    Tt: 'tt',
    Tw: 'tw',
    Ty: 'ty',
    Ug: 'ug',
    Uk: 'uk',
    Ur: 'ur',
    Uz: 'uz',
    Ve: 've',
    Vi: 'vi',
    Vo: 'vo',
    Wa: 'wa',
    Wo: 'wo',
    Xh: 'xh',
    Yi: 'yi',
    Yo: 'yo',
    Za: 'za',
    Zh: 'zh',
    Zu: 'zu'
} as const;
export type TranslationsListLanguageEnum = typeof TranslationsListLanguageEnum[keyof typeof TranslationsListLanguageEnum];
export const TranslationsListOrderingEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type TranslationsListOrderingEnum = typeof TranslationsListOrderingEnum[keyof typeof TranslationsListOrderingEnum];
